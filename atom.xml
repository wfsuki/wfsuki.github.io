<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一个树洞</title>
  
  <subtitle>一个嵌入式工程师的Blog 😊🌹</subtitle>
  <link href="https://wfsuki.github.io/atom.xml" rel="self"/>
  
  <link href="https://wfsuki.github.io/"/>
  <updated>2023-06-06T09:57:02.753Z</updated>
  <id>https://wfsuki.github.io/</id>
  
  <author>
    <name>Suki</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新讯随身wifi切卡去远控</title>
    <link href="https://wfsuki.github.io/2023/06/06/%E6%96%B0%E8%AE%AF%E9%9A%8F%E8%BA%ABwifi%E5%88%87%E5%8D%A1%E5%8E%BB%E8%BF%9C%E6%8E%A7/"/>
    <id>https://wfsuki.github.io/2023/06/06/%E6%96%B0%E8%AE%AF%E9%9A%8F%E8%BA%ABwifi%E5%88%87%E5%8D%A1%E5%8E%BB%E8%BF%9C%E6%8E%A7/</id>
    <published>2023-06-06T09:42:42.000Z</published>
    <updated>2023-06-06T09:57:02.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>淘工厂买的新讯随身wifi，切卡+去远控，变身随身小路由</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随身wifi的折腾很早就开始火了，网上教程也非常多，有一些是可以刷centos做小服务器使的，新讯这款无法刷机，但因为PCB上自带一个SIM卡槽，所以可以切换成自己的流量卡当随身wifi用，不用被商家的资费套餐限制住</p><h2 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h2><ol><li><p>开启adb</p><p>打开随身wifi助手，输入02回车（开启adb），再输入01回车（选择中芯微开ADB），浏览器显示successful就表示成功。然后重新插拔设备，重新打开随身wifi助手，就可以看到左上角显示ADB已连接</p></li><li><p>去远控、切卡</p><p>输入F回车去远控，再输入2选择传统去远控</p></li><li><p>改串号</p><ul><li><p>先安装AT驱动，使用以下指令修改串号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AT+DMOODE=1</span><br><span class="line">AT+MODIMEI=(12位串号)</span><br></pre></td></tr></table></figure></li><li><p>重启设备，进管理页面查看是否修改成功</p></li></ul></li><li><p>切卡</p><p>进入管理页面192.168.100.1，在高级设置——其他设置中选择SIM卡，管理员密码为IMEI号+999，点击保存即可</p></li><li><p>最后测试WIFI是否可用即可</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;淘工厂买的新讯随身wifi，切卡+去远控，变身随身小路由&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="https://wfsuki.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="随身wifi" scheme="https://wfsuki.github.io/tags/%E9%9A%8F%E8%BA%ABwifi/"/>
    
  </entry>
  
  <entry>
    <title>PyQt使用Qt-Material主题</title>
    <link href="https://wfsuki.github.io/2023/06/03/PyQt%E4%BD%BF%E7%94%A8Qt-Material%E4%B8%BB%E9%A2%98/"/>
    <id>https://wfsuki.github.io/2023/06/03/PyQt%E4%BD%BF%E7%94%A8Qt-Material%E4%B8%BB%E9%A2%98/</id>
    <published>2023-06-03T03:25:19.000Z</published>
    <updated>2023-06-03T03:31:39.917Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用第三方主题美化PyQt</p><span id="more"></span><h2 id="Qt-Material介绍"><a href="#Qt-Material介绍" class="headerlink" title="Qt-Material介绍"></a>Qt-Material介绍</h2><p><a href="https://qt-material.readthedocs.io/en/latest/index.html#qt-material">Qt-Material — Qt Material documentation</a></p><p><img src="/2023/06/03/PyQt%E4%BD%BF%E7%94%A8Qt-Material%E4%B8%BB%E9%A2%98/dark.gif"></p><p><img src="/2023/06/03/PyQt%E4%BD%BF%E7%94%A8Qt-Material%E4%B8%BB%E9%A2%98/light.gif"></p><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><ol><li><p>安装主题包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install qt_material</span><br></pre></td></tr></table></figure></li><li><p>添加必要的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from qt_material import list_themes</span><br><span class="line">from qt_material import apply_stylesheet</span><br><span class="line"></span><br><span class="line">print(list_themes())</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app = QtWidgets.QApplication([])</span><br><span class="line"></span><br><span class="line">    # setup stylesheet</span><br><span class="line">    apply_stylesheet(app, theme=&#x27;light_blue.xml&#x27;)</span><br><span class="line"></span><br><span class="line">    mainWindow = MainWindow()</span><br><span class="line">    mainWindow.show()</span><br><span class="line"></span><br><span class="line">    app.exec()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用第三方主题美化PyQt&lt;/p&gt;</summary>
    
    
    
    <category term="PyQt" scheme="https://wfsuki.github.io/categories/PyQt/"/>
    
    
    <category term="PyQt" scheme="https://wfsuki.github.io/tags/PyQt/"/>
    
    <category term="Qt-Material" scheme="https://wfsuki.github.io/tags/Qt-Material/"/>
    
  </entry>
  
  <entry>
    <title>PyQt使用Pyinstaller打包</title>
    <link href="https://wfsuki.github.io/2023/06/03/pyqt%E4%BD%BF%E7%94%A8pyinstaller%E6%89%93%E5%8C%85/"/>
    <id>https://wfsuki.github.io/2023/06/03/pyqt%E4%BD%BF%E7%94%A8pyinstaller%E6%89%93%E5%8C%85/</id>
    <published>2023-06-03T02:52:40.000Z</published>
    <updated>2023-06-03T03:24:30.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用Pyinstaller打包，并使用upx进行压缩</p><span id="more"></span><h2 id="常用的打包指令"><a href="#常用的打包指令" class="headerlink" title="常用的打包指令"></a>常用的打包指令</h2><p>常用的打包指令，更多参数参考Pyinstaller说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w -n 软件名字 main.py -i 001.ico </span><br></pre></td></tr></table></figure><p>打包完成后在工程目录下的&#x2F;dist&#x2F;输出单个文件</p><h2 id="使用upx进行压缩的情况"><a href="#使用upx进行压缩的情况" class="headerlink" title="使用upx进行压缩的情况"></a>使用upx进行压缩的情况</h2><ol><li><p>upx下载（注意操作系统一致）</p><p><a href="https://upx.github.io/">UPX: the Ultimate Packer for eXecutables - Homepage</a></p><p>下载完解压放到某个目录，例如E:\Work\upx-4.0.2-win64</p></li><li><p>打包时指定upx路径即可，可以减少大约20%多的内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F -w -n 软件名字 main.py -i 001.ico --upx-dir=&quot;E:\Work\upx-4.0.2-win64&quot;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Pyinstaller打包，并使用upx进行压缩&lt;/p&gt;</summary>
    
    
    
    <category term="PyQt" scheme="https://wfsuki.github.io/categories/PyQt/"/>
    
    
    <category term="Pyinstaller" scheme="https://wfsuki.github.io/tags/Pyinstaller/"/>
    
  </entry>
  
  <entry>
    <title>通过验证码平台注册官方ChatGPT账号</title>
    <link href="https://wfsuki.github.io/2023/05/24/%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B9%B3%E5%8F%B0%E6%B3%A8%E5%86%8C%E5%AE%98%E6%96%B9ChatGPT%E8%B4%A6%E5%8F%B7/"/>
    <id>https://wfsuki.github.io/2023/05/24/%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B9%B3%E5%8F%B0%E6%B3%A8%E5%86%8C%E5%AE%98%E6%96%B9ChatGPT%E8%B4%A6%E5%8F%B7/</id>
    <published>2023-05-24T00:42:01.000Z</published>
    <updated>2023-05-24T01:05:23.529Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ChatGPT需要一个国外手机号进行验证注册，可以通过验证码平台进行注册</p><span id="more"></span><h2 id="进入ChatGPT官网"><a href="#进入ChatGPT官网" class="headerlink" title="进入ChatGPT官网"></a>进入ChatGPT官网</h2><ol><li><p>点击Sign up</p><p><img src="/2023/05/24/%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B9%B3%E5%8F%B0%E6%B3%A8%E5%86%8C%E5%AE%98%E6%96%B9ChatGPT%E8%B4%A6%E5%8F%B7/20230524084509.png"></p></li><li><p>填写一个邮箱，如果是国内用户推荐使用微软邮箱注册</p><p><img src="/2023/05/24/%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B9%B3%E5%8F%B0%E6%B3%A8%E5%86%8C%E5%AE%98%E6%96%B9ChatGPT%E8%B4%A6%E5%8F%B7/20230524084547.png"></p><p>填写一个密码，下一步</p></li></ol><h2 id="通过验证码平台获取一个验证码"><a href="#通过验证码平台获取一个验证码" class="headerlink" title="通过验证码平台获取一个验证码"></a>通过验证码平台获取一个验证码</h2><ol><li><p>进入验证码平台</p><p><a href="https://sms-activate.org/cn">SMS-Activate是在线接受短信的虚拟号码服务</a></p><p>点击右上角登录，并注册一个账号，登录后点击右上角余额可以进行充值，支付宝充值，一般充个5块差不多了，可以先不充值，先看下一步</p></li><li><p>左侧选择OpenAI服务</p><p><img src="/2023/05/24/%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B9%B3%E5%8F%B0%E6%B3%A8%E5%86%8C%E5%AE%98%E6%96%B9ChatGPT%E8%B4%A6%E5%8F%B7/20230524085136.png"></p></li><li><p>选择国家</p><p>我选择的是巴西，也可以试试别的，美国不可以，有一些很便宜的小国家会出现迟迟收不到验证码的情况，可以尝试换一个国家。显示的单位是卢布，30₽约2.6人民币，如果还没充值可以右上角充个3块钱</p><p><img src="/2023/05/24/%E9%80%9A%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B9%B3%E5%8F%B0%E6%B3%A8%E5%86%8C%E5%AE%98%E6%96%B9ChatGPT%E8%B4%A6%E5%8F%B7/20230524085422.png"></p></li><li><p>将购买的手机号填写到刚才ChatGPT中作为注册手机号，然后点下一步</p></li><li><p>接着就是将收到的激活码填入ChatGPT注册验证中，这样就有了一个官方的ChatGPT账号，经过多次的更新，目前GPT使用时需要全程魔法</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;ChatGPT需要一个国外手机号进行验证注册，可以通过验证码平台进行注册&lt;/p&gt;</summary>
    
    
    
    <category term="AI" scheme="https://wfsuki.github.io/categories/AI/"/>
    
    
    <category term="ChatGPT" scheme="https://wfsuki.github.io/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>STM32+HLW8032计算家庭电路电能消耗</title>
    <link href="https://wfsuki.github.io/2023/05/23/STM32-HLW8032%E8%AE%A1%E7%AE%97%E5%AE%B6%E5%BA%AD%E7%94%B5%E8%B7%AF%E7%94%B5%E8%83%BD%E6%B6%88%E8%80%97/"/>
    <id>https://wfsuki.github.io/2023/05/23/STM32-HLW8032%E8%AE%A1%E7%AE%97%E5%AE%B6%E5%BA%AD%E7%94%B5%E8%B7%AF%E7%94%B5%E8%83%BD%E6%B6%88%E8%80%97/</id>
    <published>2023-05-23T08:02:11.000Z</published>
    <updated>2023-05-23T08:51:19.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>基于STM32+HLW8032组成的小型电力能耗检测</p><span id="more"></span><h2 id="HLW8032模块的介绍"><a href="#HLW8032模块的介绍" class="headerlink" title="HLW8032模块的介绍"></a>HLW8032模块的介绍</h2><p>HLW8032模块的使用非常简单，通过Uart与外部通信，并且默认按照4800波特率不断输出当前寄存器数据，调试中要注意串口需要设置成偶校验</p><p><img src="/2023/05/23/STM32-HLW8032%E8%AE%A1%E7%AE%97%E5%AE%B6%E5%BA%AD%E7%94%B5%E8%B7%AF%E7%94%B5%E8%83%BD%E6%B6%88%E8%80%97/O1CN01YU5K6m1vsTRK95JqU_!!2491886228.webp"></p><h3 id="内部寄存器列表"><a href="#内部寄存器列表" class="headerlink" title="内部寄存器列表"></a>内部寄存器列表</h3><p><img src="/2023/05/23/STM32-HLW8032%E8%AE%A1%E7%AE%97%E5%AE%B6%E5%BA%AD%E7%94%B5%E8%B7%AF%E7%94%B5%E8%83%BD%E6%B6%88%E8%80%97/Snipaste_2023-05-23_16-11-15.png"></p><p>实际使用中，主要关注State REG寄存器即可</p><p><img src="/2023/05/23/STM32-HLW8032%E8%AE%A1%E7%AE%97%E5%AE%B6%E5%BA%AD%E7%94%B5%E8%B7%AF%E7%94%B5%E8%83%BD%E6%B6%88%E8%80%97/Snipaste_2023-05-23_16-13-21.png"></p><h3 id="状态寄存器的主要逻辑"><a href="#状态寄存器的主要逻辑" class="headerlink" title="状态寄存器的主要逻辑"></a>状态寄存器的主要逻辑</h3><p>根据官方手册可知</p><ol><li>当 State REG &#x3D; 0xaa 时，芯片误差修正功能失效，此时电压参数寄存器、电流参数寄存器和功率参数寄存器不可用</li><li>当 State REG &#x3D; 0x55 时，芯片误差修正功能正常，此时电压参数寄存器、电流参数寄存器和功率参数寄存器可用，且电压寄存器、电流寄存器和功率寄存器未溢出</li><li>当 State REG &#x3D; 0xfx 时，芯片误差修正功能正常，此时电压参数寄存器、电流参数寄存器和功率参数寄存器可用， State REG 的相应位为 1 时表示相应的寄存器溢出，溢出表示电流、电压或功率值非常小，接近 0</li></ol><p>实际使用时，会发现未接其他负载时电压和电流是0.几，并且不断波动</p><h3 id="上位机"><a href="#上位机" class="headerlink" title="上位机"></a>上位机</h3><p>通过对比单片机和原厂提供的上位机读到的数据，可以验证单片机的计算是否正确，在未连接负载时可以测试模块是否正常，实测状态如下图</p><p><img src="/2023/05/23/STM32-HLW8032%E8%AE%A1%E7%AE%97%E5%AE%B6%E5%BA%AD%E7%94%B5%E8%B7%AF%E7%94%B5%E8%83%BD%E6%B6%88%E8%80%97/20230523162046.png"></p><h2 id="编写单片机代码"><a href="#编写单片机代码" class="headerlink" title="编写单片机代码"></a>编写单片机代码</h2><h3 id="使用STM32CubeMX搭建工程"><a href="#使用STM32CubeMX搭建工程" class="headerlink" title="使用STM32CubeMX搭建工程"></a>使用STM32CubeMX搭建工程</h3><p>我使用的是STM32F103ZET6（正点原子开发板），打开UART4，并配置波特率为4800，校验位为Even，生成工程</p><p><img src="/2023/05/23/STM32-HLW8032%E8%AE%A1%E7%AE%97%E5%AE%B6%E5%BA%AD%E7%94%B5%E8%B7%AF%E7%94%B5%E8%83%BD%E6%B6%88%E8%80%97/Snipaste_2023-05-23_16-25-19.png"></p><p>在主函数中使能串口中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__HAL_UART_ENABLE_IT(&amp;huart3, UART_IT_IDLE);</span><br></pre></td></tr></table></figure><p>中断进行数据处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void UART4_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">  HAL_UART_IRQHandler(&amp;huart4);</span><br><span class="line">  hlw8203_buff[dataLen++] = data;</span><br><span class="line">  if((hlw8203_buff[1] == 0x5A) &amp;&amp; (dataLen == 24))</span><br><span class="line">  &#123;</span><br><span class="line">      Data_Processing();</span><br><span class="line">      dataLen = 0;</span><br><span class="line">      memset(hlw8203_buff, 0x00, sizeof(hlw8203_buff));</span><br><span class="line">  &#125;</span><br><span class="line">  HAL_UART_Receive_IT(&amp;huart4, &amp;data2, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Data_Processing函数中计算并得到最终数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Data_Processing</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> VP_REG = <span class="number">0</span>, V_REG = <span class="number">0</span>, CP_REG = <span class="number">0</span>, C_REG = <span class="number">0</span>, PP_REG = <span class="number">0</span>, P_REG = <span class="number">0</span>, PF_COUNT = <span class="number">0</span>, PF = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//芯片误差修正功能正常，参数正常</span></span><br><span class="line">    <span class="keyword">if</span>(hlw8203_buff[<span class="number">0</span>] != <span class="number">0xaa</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计算电压参数寄存器</span></span><br><span class="line">        VP_REG = hlw8203_buff[<span class="number">2</span>] * <span class="number">65536</span> + hlw8203_buff[<span class="number">3</span>] * <span class="number">256</span> + hlw8203_buff[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//计算电压寄存器</span></span><br><span class="line">        V_REG = hlw8203_buff[<span class="number">5</span>] * <span class="number">65536</span> + hlw8203_buff[<span class="number">6</span>] * <span class="number">256</span> + hlw8203_buff[<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//计算电压值，1.88为电压系数，根据所采用的分压电阻大小来确定</span></span><br><span class="line">        V = (VP_REG / V_REG) * <span class="number">1.88</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;电压值：%0.2fV; &quot;,V);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算电流参数寄存器</span></span><br><span class="line">        CP_REG = hlw8203_buff[<span class="number">8</span>] * <span class="number">65536</span> + hlw8203_buff[<span class="number">9</span>] * <span class="number">256</span> + hlw8203_buff[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//计算电流寄存器</span></span><br><span class="line">        C_REG = hlw8203_buff[<span class="number">11</span>] * <span class="number">65536</span> + hlw8203_buff[<span class="number">12</span>] * <span class="number">256</span> + hlw8203_buff[<span class="number">13</span>];</span><br><span class="line">        <span class="comment">//计算电流值</span></span><br><span class="line">        C = ((CP_REG * <span class="number">100</span>) / C_REG) / <span class="number">100.0</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;电流值：%0.3fA; &quot;,C);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断实时功率是否未溢出</span></span><br><span class="line">        <span class="keyword">if</span>(hlw8203_buff[<span class="number">0</span>] &gt; <span class="number">0xf0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;未接用电设备!&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算功率参数寄存</span></span><br><span class="line">            PP_REG = hlw8203_buff[<span class="number">14</span>] * <span class="number">65536</span> + hlw8203_buff[<span class="number">15</span>] * <span class="number">256</span> + hlw8203_buff[<span class="number">16</span>];</span><br><span class="line">            <span class="comment">//计算功率寄存器</span></span><br><span class="line">            P_REG = hlw8203_buff[<span class="number">17</span>] * <span class="number">65536</span> + hlw8203_buff[<span class="number">18</span>] * <span class="number">256</span> + hlw8203_buff[<span class="number">19</span>];</span><br><span class="line">            <span class="comment">//计算有效功率</span></span><br><span class="line">            P = (PP_REG / P_REG) * <span class="number">1.88</span> * <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//printf(&quot;有效功率：%0.2fW; &quot;,P);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断数据更新寄存器最高位有没有翻转</span></span><br><span class="line">        <span class="keyword">if</span>((hlw8203_buff[<span class="number">20</span>] &amp; <span class="number">0x80</span>) != old_reg)</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">            old_reg = hlw8203_buff[<span class="number">20</span>] &amp; <span class="number">0x80</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算已用电量脉冲数</span></span><br><span class="line">        PF = (k * <span class="number">65536</span>) + (hlw8203_buff[<span class="number">21</span>] * <span class="number">256</span>) + hlw8203_buff[<span class="number">22</span>];</span><br><span class="line">        <span class="comment">//计算1度电对应的脉冲数量</span></span><br><span class="line">        PF_COUNT = ((<span class="number">100000</span> * <span class="number">3600</span>) / (PP_REG * <span class="number">1.88</span>)) * <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//计算已用电量</span></span><br><span class="line">        E_con = ((PF * <span class="number">10000</span>) / PF_COUNT) / <span class="number">10000.0</span>;</span><br><span class="line">        <span class="comment">//printf(&quot;已用电量：%0.4f°\r\n&quot;,E_con);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//芯片误差修正功能失效</span></span><br><span class="line">        <span class="comment">//printf(&quot;data error\r\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将HLW8032模块与STM32的UART4正确相连，并可持续获取到电能数据了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于STM32+HLW8032组成的小型电力能耗检测&lt;/p&gt;</summary>
    
    
    
    <category term="STM32" scheme="https://wfsuki.github.io/categories/STM32/"/>
    
    
    <category term="STM32" scheme="https://wfsuki.github.io/tags/STM32/"/>
    
    <category term="HLW8032" scheme="https://wfsuki.github.io/tags/HLW8032/"/>
    
    <category term="电能消耗" scheme="https://wfsuki.github.io/tags/%E7%94%B5%E8%83%BD%E6%B6%88%E8%80%97/"/>
    
  </entry>
  
  <entry>
    <title>通过Ping来测试WiFi模块的通信稳定性</title>
    <link href="https://wfsuki.github.io/2023/05/23/%E9%80%9A%E8%BF%87Ping%E6%9D%A5%E6%B5%8B%E8%AF%95wifi%E6%A8%A1%E5%9D%97%E7%9A%84%E9%80%9A%E4%BF%A1%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    <id>https://wfsuki.github.io/2023/05/23/%E9%80%9A%E8%BF%87Ping%E6%9D%A5%E6%B5%8B%E8%AF%95wifi%E6%A8%A1%E5%9D%97%E7%9A%84%E9%80%9A%E4%BF%A1%E7%A8%B3%E5%AE%9A%E6%80%A7/</id>
    <published>2023-05-23T06:37:21.000Z</published>
    <updated>2023-05-23T07:02:28.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在嵌入式设计开发中，产品完整了贴片组装后需要对产品的网络连接距离等性能进行测试，我们可以通过简单的Ping包形式检测WiFi模块的连接稳定性和丢包率</p><span id="more"></span><h2 id="将WiFi模块连接至路由器"><a href="#将WiFi模块连接至路由器" class="headerlink" title="将WiFi模块连接至路由器"></a>将WiFi模块连接至路由器</h2><p>连接到WiFi可以考虑以下两种办法</p><ol><li>根据产品本身的使用逻辑进行配网</li><li>如果条件不具备，也可以在出厂检测模式中，或者代码中写死目标测试WiFi的ssid&amp;password</li></ol><h2 id="查看模块的IP地址"><a href="#查看模块的IP地址" class="headerlink" title="查看模块的IP地址"></a>查看模块的IP地址</h2><p>这里也提供几种获取IP地址的办法，仅供参考</p><ol><li><p>通过路由器后台查看（最简单的一种）</p></li><li><p>通过模块本身接口（AT指令等）设置静态IP，通常用于出厂测试等</p></li><li><p>在Windows的CMD里通过arp -a命令查看所有活动的IP，注意确定电脑的网段，有多张网卡时会显示所有IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\User&gt;arp -a</span><br><span class="line">  Internet 地址         物理地址              类型</span><br><span class="line">  192.168.18.255        ff-ff-ff-ff-ff-ff     静态</span><br><span class="line">  224.0.0.22            01-00-5e-00-00-16     静态</span><br><span class="line">  224.0.0.251           01-00-5e-00-00-fb     静态</span><br><span class="line">  224.0.0.252           01-00-5e-00-00-fc     静态</span><br><span class="line">  224.189.104.223       01-00-5e-3d-68-df     静态</span><br><span class="line">  224.190.23.36         01-00-5e-3e-17-24     静态</span><br><span class="line">  225.169.88.171        01-00-5e-29-58-ab     静态</span><br><span class="line">  226.92.148.182        01-00-5e-5c-94-b6     静态</span><br><span class="line">  226.139.249.116       01-00-5e-0b-f9-74     静态</span><br><span class="line">  227.47.170.39         01-00-5e-2f-aa-27     静态</span><br><span class="line">  227.67.90.222         01-00-5e-43-5a-de     静态</span><br><span class="line">  227.158.27.60         01-00-5e-1e-1b-3c     静态</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用Ping测试网络稳定性"><a href="#使用Ping测试网络稳定性" class="headerlink" title="使用Ping测试网络稳定性"></a>使用Ping测试网络稳定性</h2><ol><li><p>使用Windows CMD进行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\User&gt;ping 192.168.1.70 -t</span><br><span class="line"></span><br><span class="line">正在 Ping 192.168.1.70 具有 32 字节的数据:</span><br><span class="line">来自 192.168.1.70 的回复: 字节=32 时间=2874ms TTL=255</span><br><span class="line">来自 192.168.1.70 的回复: 字节=32 时间=28ms TTL=255</span><br><span class="line">来自 192.168.1.70 的回复: 字节=32 时间=42ms TTL=255</span><br><span class="line">来自 192.168.1.70 的回复: 字节=32 时间=54ms TTL=255</span><br><span class="line">来自 192.168.1.70 的回复: 字节=32 时间=13ms TTL=255</span><br><span class="line">来自 192.168.1.70 的回复: 字节=32 时间=15ms TTL=255</span><br><span class="line">来自 192.168.1.70 的回复: 字节=32 时间=12ms TTL=255</span><br><span class="line">来自 192.168.1.70 的回复: 字节=32 时间=88ms TTL=255</span><br><span class="line">来自 192.168.1.70 的回复: 字节=32 时间=59ms TTL=255</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>最终可以得到一些数据，进行一些统计分析</p></li><li><p>使用其他软件进行测试</p><p>使用软件测试的好处是功能会更多，有一些软件还提供了分析，这里用ATKKPING演示</p><p><img src="/2023/05/23/%E9%80%9A%E8%BF%87Ping%E6%9D%A5%E6%B5%8B%E8%AF%95wifi%E6%A8%A1%E5%9D%97%E7%9A%84%E9%80%9A%E4%BF%A1%E7%A8%B3%E5%AE%9A%E6%80%A7/20230523145706.png"></p><p>可以看到显示了丢包率、平均延迟等，方便记录最终数据，其他还有一些更多功能的软件可以自行寻找一下，这里不做展示</p><p>通过Ping目标设备的方式是比较简单使用的测试方法，应对一些简单测试流程是够用的，毕竟如果是批量生产的设备，如果WiFi模块出了问题，基本要么不能用（完全没有WiFi），要么就是正常的</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在嵌入式设计开发中，产品完整了贴片组装后需要对产品的网络连接距离等性能进行测试，我们可以通过简单的Ping包形式检测WiFi模块的连接稳定性和丢包率&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式开发" scheme="https://wfsuki.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="测试" scheme="https://wfsuki.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="WiFi模块" scheme="https://wfsuki.github.io/tags/WiFi%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>记录hexo+github+serverles部署过程</title>
    <link href="https://wfsuki.github.io/2023/05/22/%E8%AE%B0%E5%BD%95hexo-github-serverles%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/"/>
    <id>https://wfsuki.github.io/2023/05/22/%E8%AE%B0%E5%BD%95hexo-github-serverles%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/</id>
    <published>2023-05-22T12:04:49.000Z</published>
    <updated>2023-05-23T08:57:45.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Github托管Hexo国内加载比较慢，有时候甚至还打不开，Serverless目前还是免费的，体验会好很多。虽然网上有很多教程，但还是想简单记录一下部署过程作为自己的备忘😉，我是用的是Windows环境</p><span id="more"></span><h2 id="安装node及npm"><a href="#安装node及npm" class="headerlink" title="安装node及npm"></a>安装node及npm</h2><h3 id="下载安装nodejs"><a href="#下载安装nodejs" class="headerlink" title="下载安装nodejs"></a>下载安装nodejs</h3><p><a href="https://nodejs.org/zh-cn">Node.js (nodejs.org)</a>，双击安装即可，非常方便</p><p><img src="/2023/05/22/%E8%AE%B0%E5%BD%95hexo-github-serverles%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/20230522201305.png"></p><h3 id="下载安装Git"><a href="#下载安装Git" class="headerlink" title="下载安装Git"></a>下载安装Git</h3><p><a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a>，根据自己喜好安装，所有默认也可以</p><p>安装完成后测试是否可用，在命令台输入以下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;node -v</span><br><span class="line">v18.16.0</span><br><span class="line"></span><br><span class="line">&gt;npm -v</span><br><span class="line">9.5.1</span><br><span class="line"></span><br><span class="line">&gt;git --version</span><br><span class="line">git version 2.37.0.windows.1</span><br></pre></td></tr></table></figure><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><ol><li><p>通过npm安装hexo，需要等一会儿</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>接下来可以cd到自己喜欢的目录，初始化hexo目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></li><li><p>安装组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>生成静态页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>启动服务器，在浏览器输入localhost:4000查看页面效果，一切正常就会出现hexo的欢迎页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>到这里hexo就安装好了，hexo的主题使用、文章创建等在这里不做赘述</p></li></ol><h2 id="将网站托管至Github"><a href="#将网站托管至Github" class="headerlink" title="将网站托管至Github"></a>将网站托管至Github</h2><ol><li><p>创建密钥，方便后续直接推送，进入设置界面</p><p><img src="/2023/05/22/%E8%AE%B0%E5%BD%95hexo-github-serverles%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/20230522202649.png"></p></li><li><p>创建密钥</p><p><img src="/2023/05/22/%E8%AE%B0%E5%BD%95hexo-github-serverles%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/20230522202911.png"></p></li><li><p>在本地设置用户名、邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>保存刚才申请的密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure><p>一直回车即可，将要复制到C:\Users\用户名.ssh\id_rsa.pub文件中</p></li><li><p>推送网站至Github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>到这里就可以浏览自己的网站了https:&#x2F;&#x2F;用户名.github.io&#x2F;</p></li></ol><h2 id="将网站托管至Serverless"><a href="#将网站托管至Serverless" class="headerlink" title="将网站托管至Serverless"></a>将网站托管至Serverless</h2><p>由于Github的网速捉急，所以部署到腾讯云的Serverless也是个不错的选择</p><h3 id="登录注册腾讯云"><a href="#登录注册腾讯云" class="headerlink" title="登录注册腾讯云"></a>登录注册腾讯云</h3><p>微信用户可以直接登录，<a href="https://cloud.tencent.com/">腾讯云 产业智变·云启未来 - 腾讯 (tencent.com)</a></p><h3 id="部署hexo到Serverless"><a href="#部署hexo到Serverless" class="headerlink" title="部署hexo到Serverless"></a>部署hexo到Serverless</h3><p>接下来也可以参考官方文档，写的非常详细，<a href="https://cloud.tencent.com/document/product/1154/40217">Serverless 应用中心 部署 Hexo 博客-最佳实践-文档中心-腾讯云 (tencent.com)</a></p><p>如果上面的hexo安装、Github部署已经都做过了，或者是老司机了，那么接下来总结一下就是</p><ol><li><p>在hexo目录下创建serverless.yml文件（要与public文件夹同目录）</p></li><li><p>复制默认模板到serverless.yml中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># serverless.yml</span><br><span class="line"></span><br><span class="line">component: website # (必填) 引用 component 的名称，当前用到的是 tencent-website 组件</span><br><span class="line">name: hexodemo # (必填) 该 website 组件创建的实例名称</span><br><span class="line"></span><br><span class="line">app: websiteApp # (可选) 该 website 应用名称</span><br><span class="line">stage: dev # (可选) 用于区分环境信息，默认值是 dev</span><br><span class="line"></span><br><span class="line">inputs:</span><br><span class="line">  src:</span><br><span class="line">    src: ./public # Upload static files generated by HEXO</span><br><span class="line">    index: index.html</span><br><span class="line">    # dist: ./dist</span><br><span class="line">    # hook: npm run build</span><br><span class="line">    # websitePath: ./</span><br><span class="line">  region: ap-guangzhou</span><br><span class="line">  bucketName: my-bucket</span><br><span class="line">  protocol: https</span><br></pre></td></tr></table></figure></li><li><p>一键部署云端应用及推送网站至服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scf deploy</span><br></pre></td></tr></table></figure><p>此时命令台会出现微信二维码，虽然无法配置密钥，但是个人感觉二维码扫码也挺方便的</p><p><img src="/2023/05/22/%E8%AE%B0%E5%BD%95hexo-github-serverles%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/20230522204502.png"></p><p>部署成功后，命令台会出现静态网站源码下载的链接以及应用链接，也可以在腾讯云Serverless后台进入应用界面查看网站</p><p><img src="/2023/05/22/%E8%AE%B0%E5%BD%95hexo-github-serverles%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B/20230522204210.png"></p></li></ol><p>到这里就完成了hexo+github+serverless的双平台部署了😊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Github托管Hexo国内加载比较慢，有时候甚至还打不开，Serverless目前还是免费的，体验会好很多。虽然网上有很多教程，但还是想简单记录一下部署过程作为自己的备忘😉，我是用的是Windows环境&lt;/p&gt;</summary>
    
    
    
    <category term="网站搭建" scheme="https://wfsuki.github.io/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="https://wfsuki.github.io/tags/hexo/"/>
    
    <category term="github" scheme="https://wfsuki.github.io/tags/github/"/>
    
    <category term="serverles" scheme="https://wfsuki.github.io/tags/serverles/"/>
    
    <category term="网站部署" scheme="https://wfsuki.github.io/tags/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>友善Nanopi/R2S开发板烧录OpenWRT作软路由实现全局代理</title>
    <link href="https://wfsuki.github.io/2023/05/22/%E5%8F%8B%E5%96%84Nanopi-R2S%E5%BC%80%E5%8F%91%E6%9D%BF%E7%83%A7%E5%BD%95OpenWRT%E4%BD%9C%E8%BD%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/"/>
    <id>https://wfsuki.github.io/2023/05/22/%E5%8F%8B%E5%96%84Nanopi-R2S%E5%BC%80%E5%8F%91%E6%9D%BF%E7%83%A7%E5%BD%95OpenWRT%E4%BD%9C%E8%BD%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</id>
    <published>2023-05-22T03:21:56.000Z</published>
    <updated>2023-05-22T09:24:51.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>OpenWRT软路由方案实现全局科学上网😉</p><span id="more"></span><h2 id="选择R2S的理由"><a href="#选择R2S的理由" class="headerlink" title="选择R2S的理由"></a>选择R2S的理由</h2><ul><li>优点<ol><li>1G DDR4 RAM，做软路由够用</li><li>主频默认120MHz，切换调度方式可以运行在150MHz（超频没研究测试）</li><li>两个USB3.0，作为软路由刚刚好</li><li>价格合适，我买的时候是160多元，这个配置已经算是合理了</li><li>生态支持尚可，目前已知的兼容固件已经有好几款，我使用的是ImmortalWRT</li></ol></li><li>缺点<ol><li>发热严重，如果不搭配官方金属外壳，温度直奔85℃温度墙，不过加了外壳之后温度一般维持在60℃左右，尚可接受，还有一些便宜的平替塑料外壳，带风扇的夏天也能够压到50℃附近</li><li>其中一个网口是USB转的，所以会限制出口速率，如果你家里需要千兆网，就无法使用该方案，我家的网只有300M</li></ol></li></ul><h2 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h2><ol><li><p>准备一张TF卡（尽量4G以上）以及读卡器，推荐Class10的响应较快（实测了Class4和Class10的TF卡，确实对网页打开速度等各方面有一些影响😂），下载安装BalenaEtcher烧录软件</p></li><li><p>下载最新版的ImmortalWRT固件包，r2s.img.gz，要确定是gz结尾的那个，不需要解压，直接使用BalenaEtcher进行烧录</p><p><img src="/2023/05/22/%E5%8F%8B%E5%96%84Nanopi-R2S%E5%BC%80%E5%8F%91%E6%9D%BF%E7%83%A7%E5%BD%95OpenWRT%E4%BD%9C%E8%BD%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/20230522120029.png"></p></li><li><p>烧录完成后将TF卡插入R2S中，插入网线及电源，此时红色指示灯会亮起，等待系统启动完成后网络指示灯会闪烁，此时将LAN口连接路由器，用手机等设备测试路由器网络，不出意外是有网络的了</p></li></ol><h2 id="设置全局代理"><a href="#设置全局代理" class="headerlink" title="设置全局代理"></a>设置全局代理</h2><p>在R2S确认网络环境正常后，就可以开始配置全局代理了</p><ol><li>浏览器输入192.168.2.1进入ImmortalWRT后台</li></ol><p>未完待续</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenWRT软路由方案实现全局科学上网😉&lt;/p&gt;</summary>
    
    
    
    <category term="OpenWRT" scheme="https://wfsuki.github.io/categories/OpenWRT/"/>
    
    
    <category term="R2S" scheme="https://wfsuki.github.io/tags/R2S/"/>
    
    <category term="Nanopi" scheme="https://wfsuki.github.io/tags/Nanopi/"/>
    
    <category term="OpenWRT" scheme="https://wfsuki.github.io/tags/OpenWRT/"/>
    
    <category term="软路由" scheme="https://wfsuki.github.io/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Lierda/CAT1模块NT35E使用记录/1</title>
    <link href="https://wfsuki.github.io/2023/05/22/Lierda-CAT1%E6%A8%A1%E5%9D%97NT35E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95-1/"/>
    <id>https://wfsuki.github.io/2023/05/22/Lierda-CAT1%E6%A8%A1%E5%9D%97NT35E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95-1/</id>
    <published>2023-05-22T02:26:53.000Z</published>
    <updated>2023-05-22T09:25:34.236Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Lierda CAT1模块 NT35E使用初体验</p><span id="more"></span> <h2 id="CAT1模块的简单了解"><a href="#CAT1模块的简单了解" class="headerlink" title="CAT1模块的简单了解"></a>CAT1模块的简单了解</h2><blockquote><p>Cat.1的全称是LTE UE-Category 1，其中UE是指User Equipment，是对于LTE网络下用户终端设备的无线性能的一种分类。根据3GPP的定义，将UE-Category划分为1-15共15个等级。</p><p>Cat.1是 4G LTE 网络的一个类别，可以称为“低配版”的 4G 终端，上行峰值速率5Mbit&#x2F;s，下行峰值速率10Mbit&#x2F;s，属于蜂窝物联网，是广域网</p><p>——来自网络搜索</p></blockquote><p>简单来说，CAT1模块可以使用SIM卡来连接互联网，并且还支持基站定位、GPRS定位等，相比传统的WiFi模块方案省去了用户配网操作，也不依赖于路由设备</p><h2 id="物联网卡的选择"><a href="#物联网卡的选择" class="headerlink" title="物联网卡的选择"></a>物联网卡的选择</h2><p>CAT1模块需要配合一张物联网卡才可以使用，当然在测试的时候是用过自己的电话卡也是可以的👍</p><p>以中国电信物联网卡为例，目前了解到有3种：</p><p><img src="/2023/05/22/Lierda-CAT1%E6%A8%A1%E5%9D%97NT35E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95-1/20230522110544.png"></p><p>在产品PCB中通常使用的是贴片卡，方便集成</p><h2 id="CAT1模块的使用-MQTT方式"><a href="#CAT1模块的使用-MQTT方式" class="headerlink" title="CAT1模块的使用-MQTT方式"></a>CAT1模块的使用-MQTT方式</h2><p>在NT35E上使用MQTT非常方便，与其他例如ESP系列的WiFi相似，支持AT指令集方式与模块通信。</p><p>CAT1模块与云服务器的对接流程如下图</p><p><img src="/2023/05/22/Lierda-CAT1%E6%A8%A1%E5%9D%97NT35E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95-1/20230522104628.png"></p><h3 id="连接MQTT服务器"><a href="#连接MQTT服务器" class="headerlink" title="连接MQTT服务器"></a>连接MQTT服务器</h3><ol><li><p>打开客户端连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AT+LMQTTOPEN=0,&quot;test.mosquitto.org&quot;,1883</span><br><span class="line">OK</span><br><span class="line">+LMQTTOPEN: 0,0</span><br></pre></td></tr></table></figure></li><li><p>创建连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AT+LMQTTCONN=0</span><br><span class="line">OK</span><br><span class="line">+LMQTTCONN: 0,0,0</span><br></pre></td></tr></table></figure></li><li><p>订阅MQTT主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AT+LMQTTSUBUNSUB=0,0,9,&quot;/lierda/test&quot;,2</span><br><span class="line">OK</span><br><span class="line">+LMQTTSUBUNSUB: 0,9,0,1</span><br></pre></td></tr></table></figure></li><li><p>发送MQTT消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AT+LMQTTPUB=0,9,2,0,&quot;/lierda/test&quot;,10,&quot;hello&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>接收MQTT消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+LMQTTURC: RECV,0,1,&quot;/lierda/test&quot;,11111</span><br><span class="line">+LMQTTPUB: 0,9,0</span><br></pre></td></tr></table></figure><p>收发过程可以使用MQTTX等软件进行配合测试</p><p><img src="/2023/05/22/Lierda-CAT1%E6%A8%A1%E5%9D%97NT35E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95-1/20230522105527.png"></p><p>MQTTX的下载地址：<a href="https://mqttx.app/zh">MQTTX：跨平台 MQTT 5.0 桌面客户端工具</a></p></li></ol><p>​</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Lierda CAT1模块 NT35E使用初体验&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式开发" scheme="https://wfsuki.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Lierda" scheme="https://wfsuki.github.io/tags/Lierda/"/>
    
    <category term="CAT1" scheme="https://wfsuki.github.io/tags/CAT1/"/>
    
    <category term="NT35E" scheme="https://wfsuki.github.io/tags/NT35E/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266及ESP32/ArduinoIDE环境配置</title>
    <link href="https://wfsuki.github.io/2023/05/20/ESP8266%E5%8F%8AESP32-ArduinoIDE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://wfsuki.github.io/2023/05/20/ESP8266%E5%8F%8AESP32-ArduinoIDE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-20T04:02:22.000Z</published>
    <updated>2023-05-21T03:59:30.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ESP8266及ESP32&#x2F;ArduinoIDE环境配置</p><span id="more"></span><p>在Arduino IDE中点击 文件——首选项</p><p>点击附加开发板管理网址右侧按钮</p><p><img src="/2023/05/20/ESP8266%E5%8F%8AESP32-ArduinoIDE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png"></p><p>输入以下网址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json</span><br><span class="line">http://arduino.esp8266.com/stable/package_esp8266com_index.json</span><br></pre></td></tr></table></figure><p>在Arduino IDE中点击 工具——开发板——开发板管理器</p><p><img src="/2023/05/20/ESP8266%E5%8F%8AESP32-ArduinoIDE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png"></p><p>输入ESP32搜索，点击安装，等待安装完毕即可</p><p><img src="/2023/05/20/ESP8266%E5%8F%8AESP32-ArduinoIDE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.png"></p><p>ESP8266也是一样，搜索ESP8266然后安装对应的开发板即可</p><p><img src="/2023/05/20/ESP8266%E5%8F%8AESP32-ArduinoIDE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.png"></p><p>安装完开发板支持包后，就能够选择对应的开发板啦</p><p><img src="/2023/05/20/ESP8266%E5%8F%8AESP32-ArduinoIDE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ESP8266及ESP32&amp;#x2F;ArduinoIDE环境配置&lt;/p&gt;</summary>
    
    
    
    <category term="Arduino" scheme="https://wfsuki.github.io/categories/Arduino/"/>
    
    
    <category term="Arduino" scheme="https://wfsuki.github.io/tags/Arduino/"/>
    
    <category term="ESP8266" scheme="https://wfsuki.github.io/tags/ESP8266/"/>
    
    <category term="ESP32" scheme="https://wfsuki.github.io/tags/ESP32/"/>
    
    <category term="环境配置" scheme="https://wfsuki.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Arduino/ESP12F实现网页上传固件升级</title>
    <link href="https://wfsuki.github.io/2023/05/20/Arduino-ESP12F%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E4%B8%8A%E4%BC%A0%E5%9B%BA%E4%BB%B6%E5%8D%87%E7%BA%A7/"/>
    <id>https://wfsuki.github.io/2023/05/20/Arduino-ESP12F%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E4%B8%8A%E4%BC%A0%E5%9B%BA%E4%BB%B6%E5%8D%87%E7%BA%A7/</id>
    <published>2023-05-20T03:47:03.000Z</published>
    <updated>2023-05-23T08:58:40.316Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>ESP8266在Arduino环境下实现连接wifi后，或者AP状态下进行固件上传升级，非常方便</p><span id="more"></span><p>使用的是ESP8266WebServer库，非常方便，除了固件升级，还有文件系统管理功能，大家可以自行研究，有了固件上传功能就可以不用频繁烧录了。代码比较简单，直接上代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  An OTA sample for ESP8266 by Victor.Cheung</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WiFiClient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WebServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266HTTPUpdateServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STASSID</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STASSID <span class="string">&quot;ssid&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STAPSK  <span class="string">&quot;12345678&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = STASSID;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = STAPSK;</span><br><span class="line"></span><br><span class="line">ESP8266WebServer <span class="title function_">httpServer</span><span class="params">(<span class="number">80</span>)</span>;</span><br><span class="line">ESP8266HTTPUpdateServer httpUpdater;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  Serial.println();</span><br><span class="line">  Serial.println(<span class="string">&quot;Booting Sketch...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  WiFi.mode(WIFI_STA);</span><br><span class="line">  WiFi.begin(ssid, password);</span><br><span class="line"></span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting...&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    delay(<span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  httpUpdater.setup(&amp;httpServer);</span><br><span class="line">  httpServer.begin();</span><br><span class="line"></span><br><span class="line">  Serial.print(<span class="string">&quot;HTTPUpdateServer ready! Open http://&quot;</span>);</span><br><span class="line">  Serial.print(WiFi.localIP());</span><br><span class="line">  Serial.println(<span class="string">&quot;/update in your browser&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  httpServer.handleClient();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在连接上wifi后，可以从串口中看到ESP8266的后台地址，进入后点击固件上传，选择固件就会自动更新重启了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ESP8266在Arduino环境下实现连接wifi后，或者AP状态下进行固件上传升级，非常方便&lt;/p&gt;</summary>
    
    
    
    <category term="Arduino" scheme="https://wfsuki.github.io/categories/Arduino/"/>
    
    
    <category term="Arduino" scheme="https://wfsuki.github.io/tags/Arduino/"/>
    
    <category term="ESP8266" scheme="https://wfsuki.github.io/tags/ESP8266/"/>
    
    <category term="OTA" scheme="https://wfsuki.github.io/tags/OTA/"/>
    
  </entry>
  
  <entry>
    <title>Keil编译后自动生成bin文件</title>
    <link href="https://wfsuki.github.io/2023/05/20/Keil%E7%BC%96%E8%AF%91%E5%90%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90bin%E6%96%87%E4%BB%B6/"/>
    <id>https://wfsuki.github.io/2023/05/20/Keil%E7%BC%96%E8%AF%91%E5%90%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90bin%E6%96%87%E4%BB%B6/</id>
    <published>2023-05-20T03:23:19.000Z</published>
    <updated>2023-05-22T09:25:41.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>有时候我们需要的并不是hex文件，而是需要一个bin文件用于固件升级、软件备份还原等操作，或者是通过Bootloader升级APP，此时可以使用Keil自带的脚本进行bin文件转换</p><span id="more"></span><h2 id="Keil设置"><a href="#Keil设置" class="headerlink" title="Keil设置"></a>Keil设置</h2><p>点击Keil魔术棒</p><p><img src="/2023/05/20/Keil%E7%BC%96%E8%AF%91%E5%90%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90bin%E6%96%87%E4%BB%B6/1.png"></p><p>勾选After Build&#x2F;Rebuild下的脚本，表示在每次编译后运行</p><p><img src="/2023/05/20/Keil%E7%BC%96%E8%AF%91%E5%90%8E%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90bin%E6%96%87%E4%BB%B6/2.png"></p><p>输入内容参考如下，请自行修改自己Keil安装的目录以及bin文件名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Keil_v5\ARM\ARMCLANG\bin\fromelf.exe --bin --output ./Objects/APP.bin ./Objects/Project.axf</span><br></pre></td></tr></table></figure><p>以上命令表示编译完成后，将工程目录下的&#x2F;Objects目录下的Project.axf转换成同目录下的APP.bin。再次编译就可以看到目标文件啦</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候我们需要的并不是hex文件，而是需要一个bin文件用于固件升级、软件备份还原等操作，或者是通过Bootloader升级APP，此时可以使用Keil自带的脚本进行bin文件转换&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式开发" scheme="https://wfsuki.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Keil" scheme="https://wfsuki.github.io/tags/Keil/"/>
    
    <category term="Bin文件" scheme="https://wfsuki.github.io/tags/Bin%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>GD32F470系列搭建开发环境/Keil</title>
    <link href="https://wfsuki.github.io/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/"/>
    <id>https://wfsuki.github.io/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/</id>
    <published>2023-05-20T02:58:38.000Z</published>
    <updated>2023-05-23T08:56:25.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>GD32F470使用Keil搭建开发环境</p><span id="more"></span><h2 id="为Keil安装GD32支持扩展包"><a href="#为Keil安装GD32支持扩展包" class="headerlink" title="为Keil安装GD32支持扩展包"></a>为Keil安装GD32支持扩展包</h2><p>在GD32官网下载AddOn选型插件包，例如搜索GD32F4xx AddOn，如果是F1或F3等其他系列同理</p><p><a href="https://www.gd32mcu.com/cn/download">兆易创新 (gd32mcu.com)</a></p><p><img src="/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/1.png"></p><p>点击文档图标下载</p><p><img src="/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/2.png"></p><p>下载解压完成后，会得到两个扩展包，分别是Keil的和IAR的，Keil的直接双击即可完成安装</p><p><img src="/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/6.png"></p><h2 id="为工程设置芯片选型"><a href="#为工程设置芯片选型" class="headerlink" title="为工程设置芯片选型"></a>为工程设置芯片选型</h2><p>点击Keil的魔术棒</p><p><img src="/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/7.png"></p><p>在Device中选择对应的芯片型号，点击OK</p><p><img src="/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/8.png"></p><h2 id="在Keil中下载更新组件包"><a href="#在Keil中下载更新组件包" class="headerlink" title="在Keil中下载更新组件包"></a>在Keil中下载更新组件包</h2><p>如果你是直接打开一个GD32的工程，那么Keil可能会自动弹出该页面，并自动下载所需的包文件。如果你是从0开始搭建项目，那么就需要用到这一步</p><p>点击Pack Installer按钮，进入包管理界面，左侧选择GigaDevice，并选择自己需要下载的系列</p><p><img src="/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/4.png"></p><p>双击芯片型号，在右侧的Device Specific点击Install</p><p><img src="/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/5.png"></p><p>等下下方状态栏下载进度条跑完，就下载完成啦，此时点击编译按钮尝试编译项目，如果没有工程，可以使用GD32官方的例程尝试编译，GD32的例程在这里</p><p><img src="/2023/05/20/GD32F470%E7%B3%BB%E5%88%97%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-Keil/9.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GD32F470使用Keil搭建开发环境&lt;/p&gt;</summary>
    
    
    
    <category term="GD32" scheme="https://wfsuki.github.io/categories/GD32/"/>
    
    
    <category term="GD32" scheme="https://wfsuki.github.io/tags/GD32/"/>
    
    <category term="环境搭建" scheme="https://wfsuki.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Keil" scheme="https://wfsuki.github.io/tags/Keil/"/>
    
  </entry>
  
  <entry>
    <title>CentOS8搭建Blynk物联网平台</title>
    <link href="https://wfsuki.github.io/2023/05/20/CentOS8%E6%90%AD%E5%BB%BABlynk%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0/"/>
    <id>https://wfsuki.github.io/2023/05/20/CentOS8%E6%90%AD%E5%BB%BABlynk%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0/</id>
    <published>2023-05-20T01:51:27.000Z</published>
    <updated>2023-05-22T09:26:44.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>CentOS8搭建Blynk物联网平台</p><span id="more"></span><h2 id="获取Blynk-JDK包"><a href="#获取Blynk-JDK包" class="headerlink" title="获取Blynk JDK包"></a>获取Blynk JDK包</h2><p>比较尴尬的是，Blynk的Git项目作者删除了，网上还有一些人克隆了分支，但是Release不全，目前我是用的是server-0.41.17.jar这个版本，大家可以从Git克隆的仓库或其他途径下载，也可以叫我发给你们</p><h2 id="安装java支持"><a href="#安装java支持" class="headerlink" title="安装java支持"></a>安装java支持</h2><p>从官网下载jdk-8u341-linux-x64.rpm，并安装</p><p><a href="https://www.oracle.com/java/technologies/downloads/">Java Downloads | Oracle</a></p><h2 id="开启Blynk服务"><a href="#开启Blynk服务" class="headerlink" title="开启Blynk服务"></a>开启Blynk服务</h2><p>具体的路径需要自行修改哈</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar server-0.41.17.jar -dataFolder /root/workspace/blynk</span><br></pre></td></tr></table></figure><p>开启后会显示默认的管理员账号和密码，类似这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Admin password not specified. Random password generated.</span><br><span class="line">Your Admin url is https://172.16.11.141:9443/admin</span><br><span class="line">Your Admin login email is admin@blynk.cc</span><br><span class="line">Your Admin password is IQJncCDgpk26D5TU3XFYe7yZ</span><br></pre></td></tr></table></figure><p>默认网页后台端口为9443，注意关闭防火墙以及修改云服务器的安全组配置，使用默认账号密码登录后台如下图</p><p><img src="/2023/05/20/CentOS8%E6%90%AD%E5%BB%BABlynk%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0/1.png"></p><p>密码可以在后台此处修改</p><p><img src="/2023/05/20/CentOS8%E6%90%AD%E5%BB%BABlynk%E7%89%A9%E8%81%94%E7%BD%91%E5%B9%B3%E5%8F%B0/2.png"></p><p>在APP中登录设置中填好服务器的IP和Port，就可以愉快的玩耍啦</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CentOS8搭建Blynk物联网平台&lt;/p&gt;</summary>
    
    
    
    <category term="物联网" scheme="https://wfsuki.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
    <category term="CentOS8" scheme="https://wfsuki.github.io/tags/CentOS8/"/>
    
    <category term="Blynk" scheme="https://wfsuki.github.io/tags/Blynk/"/>
    
    <category term="物联网" scheme="https://wfsuki.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>GD32F303/103移植emWin（RGB屏打点方式）</title>
    <link href="https://wfsuki.github.io/2023/05/20/GD32F303-103%E7%A7%BB%E6%A4%8DemWin%EF%BC%88RGB%E5%B1%8F%E6%89%93%E7%82%B9%E6%96%B9%E5%BC%8F%EF%BC%89/"/>
    <id>https://wfsuki.github.io/2023/05/20/GD32F303-103%E7%A7%BB%E6%A4%8DemWin%EF%BC%88RGB%E5%B1%8F%E6%89%93%E7%82%B9%E6%96%B9%E5%BC%8F%EF%BC%89/</id>
    <published>2023-05-20T00:31:18.000Z</published>
    <updated>2023-05-23T08:56:30.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本次基于GD32F303官方开发板上实现emWin移植，由于303没有图形加速器，故采用打点方式进行LCD驱动</p><span id="more"></span><h2 id="获取emWin库"><a href="#获取emWin库" class="headerlink" title="获取emWin库"></a>获取emWin库</h2><p>首先要得到一份emWin库，有很多方法可以获取</p><ul><li><p>方法1，使用MDK自带库</p><p>如果是使用Keil进行开发，仍然是最推荐使用MDK的emWin库，本次使用的是6.18版本。点击这个图标，进入Keil自带的Pack Installer中</p><p><img src="/2023/05/20/GD32F303-103%E7%A7%BB%E6%A4%8DemWin%EF%BC%88RGB%E5%B1%8F%E6%89%93%E7%82%B9%E6%96%B9%E5%BC%8F%EF%BC%89/1.png"></p><p>左侧选择GD32F3x0 Series</p><p><img src="/2023/05/20/GD32F303-103%E7%A7%BB%E6%A4%8DemWin%EF%BC%88RGB%E5%B1%8F%E6%89%93%E7%82%B9%E6%96%B9%E5%BC%8F%EF%BC%89/2.png"></p><p>右侧下载MDK-Middleware的7.13.0版本。当然找如果之前使用过ST芯片，也可以从ST芯片的包中找到，同为Cortex-M3架构，都是一样的</p><p><img src="/2023/05/20/GD32F303-103%E7%A7%BB%E6%A4%8DemWin%EF%BC%88RGB%E5%B1%8F%E6%89%93%E7%82%B9%E6%96%B9%E5%BC%8F%EF%BC%89/3.png"></p><p>如果你的Keil是默认安装的，没有修改过MDK-Middleware的下载路径，那么不出意外你会在C盘这个路径找到emWin库</p><p><img src="/2023/05/20/GD32F303-103%E7%A7%BB%E6%A4%8DemWin%EF%BC%88RGB%E5%B1%8F%E6%89%93%E7%82%B9%E6%96%B9%E5%BC%8F%EF%BC%89/4.png"></p></li><li><p>方法2，从emWin官网下载</p><p><a href="https://www.segger.com/products/user-interface/emwin/">emWin (segger.com)</a></p><p>emWin官网不知道从什么时候开始下载库需要注册登录账号，比较麻烦，但是下载一次之后可以保存起来，日后可以用，毕竟emWin几乎不更新。下载的时候选择STM32F103类似的同为M3架构的就可以</p></li><li><p>方法3，从NXP官方下载</p><p><a href="https://www.nxp.com/design/software/embedded-software/nxp-emwin-libraries:EMWIN-GRAPHICS-LIBRARY">NXP emWin Libraries | NXP Semiconductors</a></p><p>NXP的更新优化还是比较频繁的，其实是基于emWin的一个版本修改优化的，同样的只需要注意下载同为M3架构的包就可以</p></li><li><p>其他方法</p><p>还可以从一些例程，例如正点原子、野火等例程里找到</p></li></ul><h2 id="搭建工程"><a href="#搭建工程" class="headerlink" title="搭建工程"></a>搭建工程</h2><p>从GD32官方例程中找LCD驱动例程，将emWin包含进去，并确认可以实现画线、画框等LCD驱动操作，如果是自己画的PCB板子，这里还需要将自己所用的LCD驱动替换进去并确认可用。LCD驱动移植这里不做介绍，本次只记录emWin移植过程。注意如果你将lib文件添加到了Keil目录中，要注意右键lib文件，选择类型为library，否则可能会报错找不到内部emWin函数定义</p><p><img src="/2023/05/20/GD32F303-103%E7%A7%BB%E6%A4%8DemWin%EF%BC%88RGB%E5%B1%8F%E6%89%93%E7%82%B9%E6%96%B9%E5%BC%8F%EF%BC%89/5.png"></p><h2 id="修改emWin代码"><a href="#修改emWin代码" class="headerlink" title="修改emWin代码"></a>修改emWin代码</h2><ol><li><p>在GUIConf.c中修改缓存的大小，根据自己的项目大小决定，一般的测试UI，默认的也够用，如果发现之后运行起来卡在GUI_Init()函数，可以尝试扩大此处的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GUI_NUMBYTES  0x200000</span></span><br></pre></td></tr></table></figure><p>该宏定义决定了emWin初始化时生成的数组大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GUI_X_Config</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 32 bit aligned memory area</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">static</span> U32 aMemory[GUI_NUMBYTES / <span class="number">4</span>];</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Assign memory to emWin</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  GUI_ALLOC_AssignMemory(aMemory, GUI_NUMBYTES);</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Set default font</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  GUI_SetDefaultFont(GUI_FONT_6X8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用外部SDRAM，则需要将宏改为SDRAM起始地址</p></li><li><p>在GUIDRV_Template.c中添加LCD驱动的画点接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> _SetPixelIndex(GUI_DEVICE * pDevice, <span class="type">int</span> x, <span class="type">int</span> y, LCD_PIXELINDEX PixelIndex) &#123;</span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    LCDSIM_SetPixelIndex(x, y, PixelIndex, pDevice-&gt;LayerIndex);</span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Convert logical into physical coordinates (Dep. on LCDConf.h)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (LCD_MIRROR_X == 1) || (LCD_MIRROR_Y == 1) || (LCD_SWAP_XY == 1)</span></span><br><span class="line">      <span class="type">int</span> xPhys, yPhys;</span><br><span class="line"></span><br><span class="line">      xPhys = LOG2PHYS_X(x, y);</span><br><span class="line">      yPhys = LOG2PHYS_Y(x, y);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="meta">#<span class="keyword">define</span> xPhys x</span></span><br><span class="line">      <span class="meta">#<span class="keyword">define</span> yPhys y</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    GUI_USE_PARA(pDevice);</span><br><span class="line">    GUI_USE_PARA(x);</span><br><span class="line">    GUI_USE_PARA(y);</span><br><span class="line">    GUI_USE_PARA(PixelIndex);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Write into hardware ... Adapt to your system</span></span><br><span class="line">      lcd_point_set(xPhys, yPhys, PixelIndex);</span><br><span class="line">      <span class="comment">// TBD by customer...</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (LCD_MIRROR_X == 0) &amp;&amp; (LCD_MIRROR_Y == 0) &amp;&amp; (LCD_SWAP_XY == 0)</span></span><br><span class="line">      <span class="meta">#<span class="keyword">undef</span> xPhys</span></span><br><span class="line">      <span class="meta">#<span class="keyword">undef</span> yPhys</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> LCD_PIXELINDEX _GetPixelIndex(GUI_DEVICE * pDevice, <span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lcd_point_get(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在LCDConf.c中修改屏幕分辨率，使其适配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XSIZE_PHYS 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YSIZE_PHYS 320</span></span><br></pre></td></tr></table></figure></li><li><p>在SysTickHandler添加以下代码，为emWin提供心跳，如果使用uCOS等操作系统，需要在OS_CPU_SysTickHandler等函数中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> OS_TimeMS;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">OS_CPU_SysTickHandler</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPU_SR_ALLOC();</span><br><span class="line">    CPU_CRITICAL_ENTER();</span><br><span class="line">    OSIntNestingCtr++;                                      <span class="comment">/* Tell uC/OS-III that we are starting an ISR             */</span></span><br><span class="line">    CPU_CRITICAL_EXIT();</span><br><span class="line"></span><br><span class="line">    OSTimeTick();                                           <span class="comment">/* Call uC/OS-III&#x27;s OSTimeTick()                          */</span></span><br><span class="line">    OS_TimeMS++;</span><br><span class="line">    OSIntExit();                                            <span class="comment">/* Tell uC/OS-III that we are leaving the ISR             */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在主函数中依次确认添加了GPIO初始化、LCD驱动初始化、emWin的初始化函数GUI_Init，并尝试显示UI画面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LCD_Init();</span><br><span class="line">GUI_Init();</span><br><span class="line">WM_HWIN hWin = CreateWindow();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    GUI_Delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>至此不出意外应该就可以使用emWin了，但由于是使用的原始打点方法，绘图可能会比较慢，每次切换界面都会有慢慢刷屏的感觉，做做测试和小制作是够了，但是如果做产品，需要尽量使用SDRAM来提速</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本次基于GD32F303官方开发板上实现emWin移植，由于303没有图形加速器，故采用打点方式进行LCD驱动&lt;/p&gt;</summary>
    
    
    
    <category term="GD32" scheme="https://wfsuki.github.io/categories/GD32/"/>
    
    
    <category term="GD32" scheme="https://wfsuki.github.io/tags/GD32/"/>
    
    <category term="emWin" scheme="https://wfsuki.github.io/tags/emWin/"/>
    
    <category term="RGB" scheme="https://wfsuki.github.io/tags/RGB/"/>
    
    <category term="打点" scheme="https://wfsuki.github.io/tags/%E6%89%93%E7%82%B9/"/>
    
    <category term="移植" scheme="https://wfsuki.github.io/tags/%E7%A7%BB%E6%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下使用Python搭建一个http服务器</title>
    <link href="https://wfsuki.github.io/2023/05/19/CentOS%E4%B8%8B%E4%BD%BF%E7%94%A8Python%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://wfsuki.github.io/2023/05/19/CentOS%E4%B8%8B%E4%BD%BF%E7%94%A8Python%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2023-05-19T10:07:19.000Z</published>
    <updated>2023-05-21T03:47:38.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>目标是搭建一个小小的http服务器，方便处理Get&#x2F;Post请求，并在服务器做一些操作，这样自己的APP就可以与服务器交互了</p><span id="more"></span><p>以下代码仅供参考</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.debug = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/addData/&#x27;</span>,methods=[<span class="string">&#x27;post&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_data</span>():</span><br><span class="line">    <span class="keyword">if</span>  <span class="keyword">not</span> request.data:</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">    jsonData = request.data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    jsonObj = json.loads(jsonData)</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;&#123;result:ok&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/getData/&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="string">&quot;data&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">6000</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;目标是搭建一个小小的http服务器，方便处理Get&amp;#x2F;Post请求，并在服务器做一些操作，这样自己的APP就可以与服务器交互了&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://wfsuki.github.io/categories/Linux/"/>
    
    
    <category term="CentOS" scheme="https://wfsuki.github.io/tags/CentOS/"/>
    
    <category term="Linux" scheme="https://wfsuki.github.io/tags/Linux/"/>
    
    <category term="TCP" scheme="https://wfsuki.github.io/tags/TCP/"/>
    
    <category term="多线程" scheme="https://wfsuki.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Python" scheme="https://wfsuki.github.io/tags/Python/"/>
    
    <category term="Flask" scheme="https://wfsuki.github.io/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下搭建一个简单的C语言TCP多线程服务器</title>
    <link href="https://wfsuki.github.io/2023/05/19/CentOS%E4%B8%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84C%E8%AF%AD%E8%A8%80TCP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://wfsuki.github.io/2023/05/19/CentOS%E4%B8%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84C%E8%AF%AD%E8%A8%80TCP%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2023-05-19T10:06:53.000Z</published>
    <updated>2023-05-21T04:21:52.760Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://wfsuki.github.io/categories/Linux/"/>
    
    
    <category term="CentOS" scheme="https://wfsuki.github.io/tags/CentOS/"/>
    
    <category term="Linux" scheme="https://wfsuki.github.io/tags/Linux/"/>
    
    <category term="TCP" scheme="https://wfsuki.github.io/tags/TCP/"/>
    
    <category term="多线程" scheme="https://wfsuki.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python对其他软件进行OCR数字识别</title>
    <link href="https://wfsuki.github.io/2023/05/19/Python%E5%AF%B9%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8COCR%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>https://wfsuki.github.io/2023/05/19/Python%E5%AF%B9%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8COCR%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</id>
    <published>2023-05-19T09:52:30.000Z</published>
    <updated>2023-05-22T09:25:13.263Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>公司里用到了一台设备，能够测量高精度的传感器数据，但是功能有限，有些事情需要人力去反复操作，所以想到了通过Python的pytesseract库对图片进行识别，转换成数字，然后再进行一些设备控制等操作，本次记录Python识别数字的过程</p><span id="more"></span><h2 id="安装Tesseract-OCR"><a href="#安装Tesseract-OCR" class="headerlink" title="安装Tesseract-OCR"></a>安装Tesseract-OCR</h2><p><a href="https://github.com/tesseract-ocr/tesseract.git">https://github.com/tesseract-ocr/tesseract.git</a></p><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><p>简单写一个测试识别数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(pytesseract.image_to_string(Image.<span class="built_in">open</span>(<span class="string">&#x27;test.png&#x27;</span>), lang=<span class="string">&#x27;chi_sim+eng&#x27;</span>))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>截一张图，命名为test.png，丢到项目路径下，截图如下</p><p><img src="/2023/05/19/Python%E5%AF%B9%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8COCR%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/1.png"></p><p>运行代码，查看output</p><p><img src="/2023/05/19/Python%E5%AF%B9%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8COCR%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/2.png"></p><p>看起来不错，下一步就是通过不断截图+图片识别的形式来获取数据，这样我们就可以通过Python来识别其他软件上的一些数据，做更加复杂的项目测试了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;公司里用到了一台设备，能够测量高精度的传感器数据，但是功能有限，有些事情需要人力去反复操作，所以想到了通过Python的pytesseract库对图片进行识别，转换成数字，然后再进行一些设备控制等操作，本次记录Python识别数字的过程&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://wfsuki.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://wfsuki.github.io/tags/Python/"/>
    
    <category term="OCR" scheme="https://wfsuki.github.io/tags/OCR/"/>
    
    <category term="pytesseract" scheme="https://wfsuki.github.io/tags/pytesseract/"/>
    
  </entry>
  
  <entry>
    <title>Qt实现Excel读写</title>
    <link href="https://wfsuki.github.io/2023/05/19/Qt%E5%AE%9E%E7%8E%B0Excel%E8%AF%BB%E5%86%99/"/>
    <id>https://wfsuki.github.io/2023/05/19/Qt%E5%AE%9E%E7%8E%B0Excel%E8%AF%BB%E5%86%99/</id>
    <published>2023-05-19T09:51:29.000Z</published>
    <updated>2023-05-23T09:00:35.253Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Qt" scheme="https://wfsuki.github.io/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://wfsuki.github.io/tags/Qt/"/>
    
    <category term="Excel" scheme="https://wfsuki.github.io/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>Qt实现自动升级功能</title>
    <link href="https://wfsuki.github.io/2023/05/19/Qt%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8D%87%E7%BA%A7%E5%8A%9F%E8%83%BD/"/>
    <id>https://wfsuki.github.io/2023/05/19/Qt%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8D%87%E7%BA%A7%E5%8A%9F%E8%83%BD/</id>
    <published>2023-05-19T09:50:38.000Z</published>
    <updated>2023-05-23T09:00:52.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Qt" scheme="https://wfsuki.github.io/categories/Qt/"/>
    
    
    <category term="OTA" scheme="https://wfsuki.github.io/tags/OTA/"/>
    
    <category term="Qt" scheme="https://wfsuki.github.io/tags/Qt/"/>
    
  </entry>
  
</feed>
